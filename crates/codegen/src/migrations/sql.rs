//! # SQL Migration Generator
//!
//! Generates SQL migration files (CREATE TABLE, indexes, foreign keys)
//! from entity definitions in the project graph.
//!
//! Each entity produces one migration file. Files are ordered so that
//! referenced (parent) tables are created before referencing (child) tables.
//!
//! ## Supported Databases
//!
//! - **PostgreSQL**: Full feature support including UUID, JSONB, arrays
//! - **MySQL**: Full support with appropriate type mappings
//! - **SQLite**: Simplified types (TEXT, INTEGER, REAL, BLOB)

use imortal_core::{DataType, IdType, ReferentialAction};
use imortal_ir::DatabaseType;

use crate::context::{EntityInfo, GenerationContext};
use crate::{FileType, GeneratedFile};

// ============================================================================
// Public API
// ============================================================================

/// Generate all SQL migration files for every entity in the project.
///
/// Returns a `Vec<GeneratedFile>` with one `.sql` file per entity, ordered
/// by dependency (referenced tables first).
pub fn generate_migrations(ctx: &GenerationContext) -> Vec<GeneratedFile> {
    let mut files = Vec::new();

    if !ctx.generate_migrations() {
        return files;
    }

    for (index, entity) in ctx.entities().iter().enumerate() {
        let info = EntityInfo::new(entity, ctx);
        let table = info.table_name();
        let filename = ctx.migration_filename(index + 1, &table);
        let path = format!("migrations/{}", filename);

        let content = generate_create_table(&info, ctx);
        files.push(GeneratedFile::new(path, content, FileType::Sql));
    }

    files
}

// ============================================================================
// CREATE TABLE generation
// ============================================================================

/// Generate the full SQL content for one entity's migration file.
fn generate_create_table(info: &EntityInfo, ctx: &GenerationContext) -> String {
    let db = ctx.database();
    let table = info.table_name();
    let entity = info.entity;

    let mut out = String::with_capacity(2048);

    // Header comment
    out.push_str(&format!("-- Migration: Create table `{}`\n", table));
    out.push_str(&format!("-- Entity: {}\n", info.pascal_name()));
    if let Some(desc) = &entity.description {
        out.push_str(&format!("-- Description: {}\n", desc));
    }
    out.push_str(&format!("-- Database: {}\n", database_display_name(db)));
    out.push_str("-- Generated by Immortal Engine v2.0\n");
    out.push_str("\n");

    // ── UP migration ─────────────────────────────────────────────────────

    out.push_str("-- ============================================================\n");
    out.push_str("-- UP\n");
    out.push_str("-- ============================================================\n\n");

    // CREATE TABLE
    out.push_str(&format!(
        "CREATE TABLE IF NOT EXISTS {} (\n",
        quote_identifier(&table, db)
    ));

    let mut column_defs: Vec<String> = Vec::new();
    let mut constraints: Vec<String> = Vec::new();

    // ── columns ──────────────────────────────────────────────────────────

    for field in &entity.fields {
        let col_name = if field.column_name.is_empty() {
            GenerationContext::snake(&field.name)
        } else {
            field.column_name.clone()
        };

        let mut parts: Vec<String> = Vec::new();

        // Column name
        parts.push(format!("    {}", quote_identifier(&col_name, db)));

        // Column type
        if field.is_primary_key {
            parts.push(GenerationContext::pk_sql_type(info.id_type(), db));
        } else {
            let is_nullable = matches!(field.data_type, DataType::Optional(_));
            let sql_ty = GenerationContext::sql_type(&field.data_type, db);
            parts.push(sql_ty);

            // NOT NULL (skip for optional types and for primary keys handled above)
            if field.required && !is_nullable {
                parts.push("NOT NULL".to_string());
            }
        }

        // PRIMARY KEY (inline for simplicity)
        if field.is_primary_key {
            parts.push("PRIMARY KEY".to_string());
        }

        // UNIQUE
        if field.unique && !field.is_primary_key {
            parts.push("UNIQUE".to_string());
        }

        // DEFAULT
        if let Some(default_clause) = GenerationContext::sql_default(field, db) {
            if !default_clause.is_empty() {
                parts.push(default_clause);
            }
        }

        column_defs.push(parts.join(" "));

        // ── foreign key constraint (out-of-line) ─────────────────────────
        if field.is_foreign_key {
            if let Some(fk) = &field.foreign_key_ref {
                let ref_entity = ctx.entity_by_id(fk.entity_id);
                let ref_table = ref_entity
                    .map(|e| {
                        if e.table_name.is_empty() {
                            GenerationContext::table_name(&e.name)
                        } else {
                            e.table_name.clone()
                        }
                    })
                    .unwrap_or_else(|| GenerationContext::table_name(&fk.entity_name));

                let ref_col = if fk.field_name.is_empty() {
                    "id".to_string()
                } else {
                    fk.field_name.clone()
                };

                let on_delete = referential_action_sql(&fk.on_delete);
                let on_update = referential_action_sql(&fk.on_update);

                let constraint_name = format!("fk_{}_{}", table, col_name);

                constraints.push(format!(
                    "    CONSTRAINT {} FOREIGN KEY ({}) REFERENCES {} ({}) ON DELETE {} ON UPDATE {}",
                    quote_identifier(&constraint_name, db),
                    quote_identifier(&col_name, db),
                    quote_identifier(&ref_table, db),
                    quote_identifier(&ref_col, db),
                    on_delete,
                    on_update,
                ));
            }
        }
    }

    // ── timestamp columns (if enabled and not already present) ───────────
    if info.has_timestamps() {
        let has_created = entity
            .fields
            .iter()
            .any(|f| f.name == "created_at" || f.column_name == "created_at");
        let has_updated = entity
            .fields
            .iter()
            .any(|f| f.name == "updated_at" || f.column_name == "updated_at");

        if !has_created {
            column_defs.push(format!(
                "    {} {} NOT NULL DEFAULT CURRENT_TIMESTAMP",
                quote_identifier("created_at", db),
                GenerationContext::sql_type(&DataType::DateTime, db),
            ));
        }
        if !has_updated {
            column_defs.push(format!(
                "    {} {} NOT NULL DEFAULT CURRENT_TIMESTAMP",
                quote_identifier("updated_at", db),
                GenerationContext::sql_type(&DataType::DateTime, db),
            ));
        }
    }

    // ── soft-delete column ───────────────────────────────────────────────
    if info.has_soft_delete() {
        let has_deleted = entity
            .fields
            .iter()
            .any(|f| f.name == "deleted_at" || f.column_name == "deleted_at");
        if !has_deleted {
            column_defs.push(format!(
                "    {} {} DEFAULT NULL",
                quote_identifier("deleted_at", db),
                GenerationContext::sql_type(&DataType::DateTime, db),
            ));
        }
    }

    // Combine columns and constraints
    let mut all_lines: Vec<String> = column_defs;
    all_lines.extend(constraints);

    out.push_str(&all_lines.join(",\n"));
    out.push('\n');
    out.push_str(");\n\n");

    // ── indexes ──────────────────────────────────────────────────────────

    let indexes = generate_indexes(info, ctx);
    if !indexes.is_empty() {
        out.push_str(&indexes);
        out.push('\n');
    }

    // ── comments (PostgreSQL only) ───────────────────────────────────────

    if db == DatabaseType::PostgreSQL {
        if let Some(desc) = &entity.description {
            out.push_str(&format!(
                "COMMENT ON TABLE {} IS '{}';\n",
                quote_identifier(&table, db),
                desc.replace('\'', "''")
            ));
        }
        for field in &entity.fields {
            if let Some(desc) = &field.description {
                let col_name = if field.column_name.is_empty() {
                    GenerationContext::snake(&field.name)
                } else {
                    field.column_name.clone()
                };
                out.push_str(&format!(
                    "COMMENT ON COLUMN {}.{} IS '{}';\n",
                    quote_identifier(&table, db),
                    quote_identifier(&col_name, db),
                    desc.replace('\'', "''")
                ));
            }
        }
        out.push('\n');
    }

    // ── DOWN migration ───────────────────────────────────────────────────

    out.push_str("-- ============================================================\n");
    out.push_str("-- DOWN\n");
    out.push_str("-- ============================================================\n\n");

    out.push_str(&format!(
        "-- DROP TABLE IF EXISTS {};\n",
        quote_identifier(&table, db),
    ));

    out
}

// ============================================================================
// Index generation
// ============================================================================

/// Generate CREATE INDEX statements for fields marked as `indexed` and for
/// foreign key columns.
fn generate_indexes(info: &EntityInfo, ctx: &GenerationContext) -> String {
    let db = ctx.database();
    let table = info.table_name();
    let entity = info.entity;

    let mut out = String::new();

    for field in &entity.fields {
        // Skip primary keys (already indexed) and non-indexed fields
        if field.is_primary_key {
            continue;
        }

        let col_name = if field.column_name.is_empty() {
            GenerationContext::snake(&field.name)
        } else {
            field.column_name.clone()
        };

        let needs_index = field.indexed || field.is_foreign_key;

        if needs_index {
            let index_name = format!("idx_{}_{}", table, col_name);

            if field.unique {
                out.push_str(&format!(
                    "CREATE UNIQUE INDEX IF NOT EXISTS {} ON {} ({});\n",
                    quote_identifier(&index_name, db),
                    quote_identifier(&table, db),
                    quote_identifier(&col_name, db),
                ));
            } else {
                out.push_str(&format!(
                    "CREATE INDEX IF NOT EXISTS {} ON {} ({});\n",
                    quote_identifier(&index_name, db),
                    quote_identifier(&table, db),
                    quote_identifier(&col_name, db),
                ));
            }
        }
    }

    // Soft-delete index (if enabled)
    if info.has_soft_delete() {
        let index_name = format!("idx_{}_deleted_at", table);
        out.push_str(&format!(
            "CREATE INDEX IF NOT EXISTS {} ON {} ({});\n",
            quote_identifier(&index_name, db),
            quote_identifier(&table, db),
            quote_identifier("deleted_at", db),
        ));
    }

    out
}

// ============================================================================
// Helper functions
// ============================================================================

/// Quote an identifier according to the target database dialect.
fn quote_identifier(name: &str, db: DatabaseType) -> String {
    match db {
        DatabaseType::PostgreSQL | DatabaseType::SQLite => format!("\"{}\"", name),
        DatabaseType::MySQL => format!("`{}`", name),
    }
}

/// Map a `ReferentialAction` to its SQL keyword.
fn referential_action_sql(action: &ReferentialAction) -> &'static str {
    match action {
        ReferentialAction::Cascade => "CASCADE",
        ReferentialAction::SetNull => "SET NULL",
        ReferentialAction::Restrict => "RESTRICT",
        ReferentialAction::NoAction => "NO ACTION",
        ReferentialAction::SetDefault => "SET DEFAULT",
    }
}

/// Human-readable database name for migration header comments.
fn database_display_name(db: DatabaseType) -> &'static str {
    match db {
        DatabaseType::PostgreSQL => "PostgreSQL",
        DatabaseType::MySQL => "MySQL",
        DatabaseType::SQLite => "SQLite",
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use imortal_core::{DataType, IdType, ReferentialAction};
    use imortal_ir::{DatabaseType, Entity, EntityConfig, Field, ForeignKeyRef, ProjectGraph};
    use uuid::Uuid;

    /// Helper: create a basic entity with some fields.
    fn make_user_entity() -> Entity {
        let mut entity = Entity::new("User");
        entity.config.timestamps = true;

        // Add an email field
        let mut email_field = Field::new("email", DataType::String);
        email_field.required = true;
        email_field.unique = true;
        email_field.indexed = true;
        entity.fields.push(email_field);

        // Add a name field
        let mut name_field = Field::new("name", DataType::String);
        name_field.required = true;
        entity.fields.push(name_field);

        entity
    }

    fn make_post_entity(user_entity_id: Uuid) -> Entity {
        let mut entity = Entity::new("Post");
        entity.config.timestamps = true;

        // Title
        let mut title = Field::new("title", DataType::String);
        title.required = true;
        entity.fields.push(title);

        // Content
        let content = Field::new("content", DataType::Text);
        entity.fields.push(content);

        // Foreign key to user
        let mut user_id_field = Field::new("user_id", DataType::Uuid);
        user_id_field.required = true;
        user_id_field.is_foreign_key = true;
        user_id_field.indexed = true;
        user_id_field.foreign_key_ref = Some(ForeignKeyRef {
            entity_id: user_entity_id,
            entity_name: "User".to_string(),
            field_name: "id".to_string(),
            on_delete: ReferentialAction::Cascade,
            on_update: ReferentialAction::NoAction,
        });
        entity.fields.push(user_id_field);

        entity
    }

    #[test]
    fn test_generate_migrations_empty_project() {
        let project = ProjectGraph::new("test");
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);
        assert!(files.is_empty());
    }

    #[test]
    fn test_generate_migrations_single_entity() {
        let mut project = ProjectGraph::new("blog");
        let user = make_user_entity();
        project.add_entity(user);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        assert_eq!(files.len(), 1);
        assert!(files[0].path.to_string_lossy().contains("create_users.sql"));

        let content = &files[0].content;
        assert!(content.contains("CREATE TABLE IF NOT EXISTS"));
        assert!(content.contains("\"users\""));
        assert!(content.contains("\"email\""));
        assert!(content.contains("VARCHAR(255)"));
        assert!(content.contains("NOT NULL"));
        assert!(content.contains("UNIQUE"));
        assert!(content.contains("PRIMARY KEY"));
        assert!(content.contains("\"created_at\""));
        assert!(content.contains("\"updated_at\""));
    }

    #[test]
    fn test_generate_migrations_with_fk() {
        let mut project = ProjectGraph::new("blog");
        let user = make_user_entity();
        let user_id = user.id;
        project.add_entity(user);

        let post = make_post_entity(user_id);
        project.add_entity(post);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        assert_eq!(files.len(), 2);

        // Find the posts migration
        let post_migration = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("posts"))
            .expect("should have posts migration");

        let content = &post_migration.content;
        assert!(content.contains("FOREIGN KEY"));
        assert!(content.contains("REFERENCES"));
        assert!(content.contains("\"users\""));
        assert!(content.contains("ON DELETE CASCADE"));
        assert!(content.contains("idx_posts_user_id"));
    }

    #[test]
    fn test_generate_migrations_mysql() {
        let mut project = ProjectGraph::new("shop");
        project.config.database = DatabaseType::MySQL;

        let user = make_user_entity();
        project.add_entity(user);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        assert_eq!(files.len(), 1);

        let content = &files[0].content;
        // MySQL uses backtick quoting
        assert!(content.contains("`users`"));
        assert!(content.contains("`email`"));
        assert!(content.contains("MySQL"));
    }

    #[test]
    fn test_generate_migrations_sqlite() {
        let mut project = ProjectGraph::new("app");
        project.config.database = DatabaseType::SQLite;

        let user = make_user_entity();
        project.add_entity(user);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        assert_eq!(files.len(), 1);

        let content = &files[0].content;
        assert!(content.contains("TEXT")); // SQLite maps VARCHAR to TEXT
        assert!(content.contains("SQLite"));
    }

    #[test]
    fn test_generate_migrations_soft_delete() {
        let mut project = ProjectGraph::new("cms");
        let mut entity = Entity::new("Article");
        entity.config.timestamps = true;
        entity.config.soft_delete = true;

        let mut title = Field::new("title", DataType::String);
        title.required = true;
        entity.fields.push(title);

        project.add_entity(entity);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        let content = &files[0].content;
        assert!(content.contains("\"deleted_at\""));
        assert!(content.contains("DEFAULT NULL"));
        assert!(content.contains("idx_articles_deleted_at"));
    }

    #[test]
    fn test_generate_migrations_disabled() {
        let project = ProjectGraph::new("test");
        let config = crate::GeneratorConfig::new().without_migrations();
        let ctx = GenerationContext::from_project(&project, config);
        let files = generate_migrations(&ctx);
        assert!(files.is_empty());
    }

    #[test]
    fn test_referential_action_sql() {
        assert_eq!(
            referential_action_sql(&ReferentialAction::Cascade),
            "CASCADE"
        );
        assert_eq!(
            referential_action_sql(&ReferentialAction::SetNull),
            "SET NULL"
        );
        assert_eq!(
            referential_action_sql(&ReferentialAction::Restrict),
            "RESTRICT"
        );
        assert_eq!(
            referential_action_sql(&ReferentialAction::NoAction),
            "NO ACTION"
        );
    }

    #[test]
    fn test_quote_identifier() {
        assert_eq!(
            quote_identifier("users", DatabaseType::PostgreSQL),
            "\"users\""
        );
        assert_eq!(quote_identifier("users", DatabaseType::MySQL), "`users`");
        assert_eq!(quote_identifier("users", DatabaseType::SQLite), "\"users\"");
    }

    #[test]
    fn test_database_display_name() {
        assert_eq!(
            database_display_name(DatabaseType::PostgreSQL),
            "PostgreSQL"
        );
        assert_eq!(database_display_name(DatabaseType::MySQL), "MySQL");
        assert_eq!(database_display_name(DatabaseType::SQLite), "SQLite");
    }

    #[test]
    fn test_down_migration_present() {
        let mut project = ProjectGraph::new("test");
        let entity = Entity::new("User");
        project.add_entity(entity);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        let content = &files[0].content;
        assert!(content.contains("-- DOWN"));
        assert!(content.contains("DROP TABLE IF EXISTS"));
    }

    #[test]
    fn test_migration_ordering() {
        let mut project = ProjectGraph::new("blog");
        let user = make_user_entity();
        let user_id = user.id;
        project.add_entity(user);

        let post = make_post_entity(user_id);
        project.add_entity(post);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        // The users table migration should come before the posts table migration
        let user_idx = files
            .iter()
            .position(|f| f.path.to_string_lossy().contains("users"))
            .unwrap();
        let post_idx = files
            .iter()
            .position(|f| f.path.to_string_lossy().contains("posts"))
            .unwrap();

        assert!(
            user_idx < post_idx,
            "users migration (index {}) should come before posts migration (index {})",
            user_idx,
            post_idx
        );
    }

    #[test]
    fn test_multiple_data_types() {
        let mut project = ProjectGraph::new("types_test");

        let mut entity = Entity::new("TypeTest");
        entity.config.timestamps = false;

        let fields_to_add = vec![
            ("count", DataType::Int32),
            ("big_count", DataType::Int64),
            ("score", DataType::Float64),
            ("active", DataType::Bool),
            ("data", DataType::Json),
            ("content", DataType::Text),
            ("birthday", DataType::Date),
            ("avatar", DataType::Bytes),
        ];

        for (name, dt) in fields_to_add {
            let mut f = Field::new(name, dt);
            f.required = true;
            entity.fields.push(f);
        }

        project.add_entity(entity);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        let content = &files[0].content;
        assert!(content.contains("INTEGER")); // Int32
        assert!(content.contains("BIGINT")); // Int64
        assert!(content.contains("DOUBLE PRECISION")); // Float64 (PostgreSQL)
        assert!(content.contains("BOOLEAN")); // Bool
        assert!(content.contains("JSONB")); // Json (PostgreSQL)
        assert!(content.contains("TEXT")); // Text
        assert!(content.contains("DATE")); // Date
        assert!(content.contains("BYTEA")); // Bytes (PostgreSQL)
    }

    #[test]
    fn test_optional_field_no_not_null() {
        let mut project = ProjectGraph::new("opt_test");

        let mut entity = Entity::new("Profile");
        entity.config.timestamps = false;

        let bio = Field::new("bio", DataType::Optional(Box::new(DataType::Text)));
        entity.fields.push(bio);

        project.add_entity(entity);

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_migrations(&ctx);

        let content = &files[0].content;
        // The bio column should NOT have NOT NULL since it's Optional
        let bio_line = content
            .lines()
            .find(|line| line.contains("\"bio\""))
            .expect("should have bio column");
        assert!(
            !bio_line.contains("NOT NULL"),
            "Optional field should not have NOT NULL: {}",
            bio_line
        );
    }
}
