//! # Frontend Generation (Dioxus Web)
//!
//! This module generates a complete Dioxus Web frontend for fullstack projects.
//! It is only invoked when `ctx.is_fullstack()` returns `true`.
//!
//! ## Generated Structure
//!
//! ```text
//! frontend/
//! ├── Cargo.toml
//! ├── Dioxus.toml
//! ├── assets/
//! │   └── tailwind.css
//! └── src/
//!     ├── main.rs
//!     ├── app.rs
//!     ├── router.rs
//!     ├── components/
//!     │   ├── mod.rs
//!     │   ├── navbar.rs
//!     │   ├── sidebar.rs
//!     │   ├── table.rs
//!     │   └── form.rs
//!     ├── pages/
//!     │   ├── mod.rs
//!     │   ├── home.rs
//!     │   └── {entity}_list.rs / {entity}_form.rs  (per entity)
//!     └── api/
//!         ├── mod.rs
//!         └── client.rs
//!
//! shared/
//! ├── Cargo.toml
//! └── src/
//!     └── lib.rs       # DTOs shared between frontend and backend
//! ```
//!
//! ## Architecture
//!
//! The generated frontend uses:
//!
//! - **Dioxus 0.6 Web** for the UI framework
//! - **Tailwind CSS** for styling
//! - **reqwest** for HTTP API calls
//! - A **shared** crate for DTOs used by both frontend and backend
//!
//! The `generate_frontend` function orchestrates all sub-generators and
//! collects the results into a flat `Vec<GeneratedFile>`.

pub mod api_client;
pub mod dioxus;
pub mod pages;

use crate::context::{EntityInfo, GenerationContext};
use crate::rust::file_header;
use crate::{FileType, GeneratedFile};

// ============================================================================
// Public API
// ============================================================================

/// Generate the complete Dioxus frontend for a fullstack project.
///
/// Returns an empty `Vec` if the project is not configured as fullstack.
///
/// # Generated Files
///
/// - Workspace `Cargo.toml` (replaces the single-crate one)
/// - `shared/` crate with DTOs
/// - `frontend/` crate with Dioxus Web app
///   - Scaffold: Cargo.toml, Dioxus.toml, main.rs, app.rs, router.rs
///   - Components: navbar, sidebar, table, form
///   - Pages: home + per-entity list/form pages
///   - API client: type-safe reqwest wrapper
///   - Assets: Tailwind CSS
pub fn generate_frontend(ctx: &GenerationContext) -> Vec<GeneratedFile> {
    if !ctx.is_fullstack() {
        return Vec::new();
    }

    let mut files: Vec<GeneratedFile> = Vec::new();

    // ── Workspace root Cargo.toml ────────────────────────────────────────
    files.push(generate_workspace_cargo_toml(ctx));

    // ── Shared crate ─────────────────────────────────────────────────────
    files.extend(generate_shared_crate(ctx));

    // ── Frontend scaffold ────────────────────────────────────────────────
    files.push(generate_frontend_cargo_toml(ctx));
    files.push(generate_dioxus_toml(ctx));
    files.push(generate_tailwind_css(ctx));
    files.push(generate_frontend_main(ctx));
    files.push(generate_frontend_app(ctx));
    files.push(generate_frontend_router(ctx));

    // ── Components ───────────────────────────────────────────────────────
    files.extend(dioxus::generate_components(ctx));

    // ── Pages ────────────────────────────────────────────────────────────
    files.extend(pages::generate_pages(ctx));

    // ── API client ───────────────────────────────────────────────────────
    files.extend(api_client::generate_api_client(ctx));

    files
}

// ============================================================================
// Workspace Cargo.toml (fullstack mode)
// ============================================================================

/// Generate the workspace-level `Cargo.toml` that ties together backend,
/// frontend, and shared crates.
///
/// In fullstack mode, this **replaces** the single-crate `Cargo.toml`
/// generated by the backend generator. The backend files are moved under
/// a `backend/` prefix by the generator orchestrator.
fn generate_workspace_cargo_toml(ctx: &GenerationContext) -> GeneratedFile {
    let pkg = ctx.package_name();

    let content = format!(
        r#"# =============================================================================
# {pkg} — Fullstack Workspace
# Generated by Immortal Engine v2.0
# =============================================================================

[workspace]
resolver = "2"
members = [
    "backend",
    "frontend",
    "shared",
]

[workspace.package]
version = "0.1.0"
edition = "{edition}"
publish = false

[workspace.dependencies]
# Shared dependencies used by multiple crates
serde = {{ version = "1", features = ["derive"] }}
serde_json = "1"
uuid = {{ version = "1", features = ["v4", "serde"] }}
chrono = {{ version = "0.4", features = ["serde"] }}
thiserror = "2"

# Internal crates
shared = {{ path = "shared" }}

[profile.release]
opt-level = 3
lto = true
strip = true
codegen-units = 1
"#,
        edition = ctx.rust_edition(),
    );

    GeneratedFile::new("Cargo.toml", content, FileType::Toml)
}

// ============================================================================
// Shared crate (DTOs shared between frontend and backend)
// ============================================================================

/// Generate the `shared/` crate containing DTOs used by both frontend and
/// backend.
fn generate_shared_crate(ctx: &GenerationContext) -> Vec<GeneratedFile> {
    let mut files = Vec::new();

    // shared/Cargo.toml
    let pkg = ctx.package_name();
    let cargo_content = format!(
        r#"[package]
name = "shared"
version.workspace = true
edition.workspace = true
publish.workspace = true

[dependencies]
serde = {{ workspace = true }}
serde_json = {{ workspace = true }}
uuid = {{ workspace = true }}
chrono = {{ workspace = true }}
"#,
    );
    files.push(GeneratedFile::new(
        "shared/Cargo.toml",
        cargo_content,
        FileType::Toml,
    ));

    // shared/src/lib.rs — re-exports of all entity DTOs
    let mut lib_content = String::with_capacity(4096);

    lib_content.push_str(&file_header(
        "Shared types (DTOs) used by both backend and frontend.",
    ));

    lib_content.push_str("use serde::{Deserialize, Serialize};\n");
    lib_content.push_str("use uuid::Uuid;\n");

    // Check if we need chrono
    let needs_chrono = ctx.entities().iter().any(|e| e.config.timestamps);
    if needs_chrono {
        lib_content.push_str("use chrono::{DateTime, Utc};\n");
    }

    lib_content.push('\n');

    // Generate DTOs for each entity
    for entity in ctx.entities() {
        let info = EntityInfo::new(entity, ctx);
        let pascal = info.pascal_name();
        let snake = info.snake_name();

        lib_content.push_str(&format!(
            "// ============================================================================\n"
        ));
        lib_content.push_str(&format!("// {} DTOs\n", pascal));
        lib_content.push_str(&format!(
            "// ============================================================================\n\n"
        ));

        // Create DTO
        let create_name = GenerationContext::create_dto_name(&entity.name);
        lib_content.push_str(&format!("/// Payload for creating a new {}.\n", pascal));
        lib_content.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        lib_content.push_str(&format!("pub struct {} {{\n", create_name));

        for field in ctx.create_fields(entity) {
            let field_name = GenerationContext::snake(&field.name);
            let rust_type = shared_rust_type(&field.data_type, field.required);
            lib_content.push_str(&format!("    pub {}: {},\n", field_name, rust_type));
        }
        lib_content.push_str("}\n\n");

        // Update DTO
        let update_name = GenerationContext::update_dto_name(&entity.name);
        lib_content.push_str(&format!(
            "/// Payload for updating an existing {}.\n",
            pascal
        ));
        lib_content.push_str("#[derive(Debug, Clone, Default, Serialize, Deserialize)]\n");
        lib_content.push_str(&format!("pub struct {} {{\n", update_name));

        for field in ctx.update_fields(entity) {
            let field_name = GenerationContext::snake(&field.name);
            let inner_type = shared_rust_type(&field.data_type, true);
            lib_content.push_str(&format!(
                "    pub {}: Option<{}>,\n",
                field_name, inner_type
            ));
        }
        lib_content.push_str("}\n\n");

        // Response DTO
        let response_name = GenerationContext::response_dto_name(&entity.name);
        lib_content.push_str(&format!("/// Response representation of a {}.\n", pascal));
        lib_content.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        lib_content.push_str(&format!("pub struct {} {{\n", response_name));

        for field in ctx.response_fields(entity) {
            let field_name = GenerationContext::snake(&field.name);
            let rust_type = shared_rust_type(&field.data_type, field.required);
            lib_content.push_str(&format!("    pub {}: {},\n", field_name, rust_type));
        }

        // Timestamps
        if entity.config.timestamps {
            let has_created = entity.fields.iter().any(|f| f.name == "created_at");
            let has_updated = entity.fields.iter().any(|f| f.name == "updated_at");
            if !has_created {
                lib_content.push_str("    pub created_at: DateTime<Utc>,\n");
            }
            if !has_updated {
                lib_content.push_str("    pub updated_at: DateTime<Utc>,\n");
            }
        }

        lib_content.push_str("}\n\n");
    }

    // Pagination types
    lib_content.push_str(
        r#"// ============================================================================
// Pagination
// ============================================================================

/// Paginated API response wrapper.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PaginatedResponse<T> {
    pub items: Vec<T>,
    pub total: u64,
    pub page: u64,
    pub per_page: u64,
    pub total_pages: u64,
}

/// Query parameters for paginated list endpoints.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct PaginationParams {
    pub page: Option<u64>,
    pub per_page: Option<u64>,
}

// ============================================================================
// API Error
// ============================================================================

/// Standard API error response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiError {
    pub error: String,
    pub message: String,
}
"#,
    );

    files.push(GeneratedFile::new(
        "shared/src/lib.rs",
        lib_content,
        FileType::Rust,
    ));

    files
}

// ============================================================================
// Frontend Cargo.toml
// ============================================================================

fn generate_frontend_cargo_toml(ctx: &GenerationContext) -> GeneratedFile {
    let pkg = ctx.package_name();

    let content = format!(
        r#"[package]
name = "{pkg}-frontend"
version.workspace = true
edition.workspace = true
publish.workspace = true

[dependencies]
# UI Framework
dioxus = {{ version = "0.6", features = ["web"] }}

# HTTP Client
reqwest = {{ version = "0.12", features = ["json"] }}

# Serialization
serde = {{ workspace = true }}
serde_json = {{ workspace = true }}

# Identifiers
uuid = {{ workspace = true }}

# Date/Time
chrono = {{ workspace = true }}

# Error handling
thiserror = {{ workspace = true }}

# Logging
tracing = "0.1"
web-sys = "0.3"

# Internal
shared = {{ workspace = true }}
"#,
    );

    GeneratedFile::new("frontend/Cargo.toml", content, FileType::Toml)
}

// ============================================================================
// Dioxus.toml
// ============================================================================

fn generate_dioxus_toml(ctx: &GenerationContext) -> GeneratedFile {
    let pkg = ctx.package_name();

    let content = format!(
        r#"[application]
name = "{pkg}"
default_platform = "web"

[web.app]
title = "{pkg}"

[web.watcher]
reload_html = true
watch_path = ["src", "assets"]

[web.resource]
style = ["assets/tailwind.css"]

[web.resource.dev]
style = ["assets/tailwind.css"]
"#,
    );

    GeneratedFile::new("frontend/Dioxus.toml", content, FileType::Toml)
}

// ============================================================================
// Tailwind CSS
// ============================================================================

fn generate_tailwind_css(_ctx: &GenerationContext) -> GeneratedFile {
    let content = r#"/* =============================================================================
 * Tailwind CSS — Generated by Immortal Engine v2.0
 *
 * This is a minimal Tailwind setup. For production use, install Tailwind CLI
 * and compile from a source file with @tailwind directives.
 *
 * Quick start:
 *   npm install -D tailwindcss
 *   npx tailwindcss -i ./assets/input.css -o ./assets/tailwind.css --watch
 * ============================================================================= */

/* Reset & base styles */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
                 'Helvetica Neue', Arial, sans-serif;
    background-color: #0f172a;
    color: #e2e8f0;
    line-height: 1.6;
}

/* Layout */
.app-container {
    display: flex;
    min-height: 100vh;
}

.sidebar {
    width: 16rem;
    background-color: #1e293b;
    border-right: 1px solid #334155;
    padding: 1rem 0;
    display: flex;
    flex-direction: column;
}

.sidebar-header {
    padding: 0 1rem 1rem;
    border-bottom: 1px solid #334155;
    font-size: 1.25rem;
    font-weight: 700;
    color: #818cf8;
}

.sidebar-nav {
    flex: 1;
    padding: 0.5rem 0;
}

.sidebar-link {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.625rem 1rem;
    color: #94a3b8;
    text-decoration: none;
    font-size: 0.875rem;
    transition: all 0.15s ease;
}

.sidebar-link:hover {
    background-color: #334155;
    color: #e2e8f0;
}

.sidebar-link.active {
    background-color: #312e81;
    color: #818cf8;
    border-right: 3px solid #818cf8;
}

.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Navbar */
.navbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1.5rem;
    background-color: #1e293b;
    border-bottom: 1px solid #334155;
}

.navbar-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: #f1f5f9;
}

.navbar-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* Content area */
.content {
    flex: 1;
    padding: 1.5rem;
    overflow-y: auto;
}

/* Cards */
.card {
    background-color: #1e293b;
    border: 1px solid #334155;
    border-radius: 0.75rem;
    padding: 1.5rem;
    margin-bottom: 1rem;
}

.card-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1rem;
}

.card-title {
    font-size: 1.125rem;
    font-weight: 600;
    color: #f1f5f9;
}

/* Tables */
.table-container {
    overflow-x: auto;
    border: 1px solid #334155;
    border-radius: 0.5rem;
}

table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
}

thead {
    background-color: #1e293b;
}

th {
    padding: 0.75rem 1rem;
    text-align: left;
    font-weight: 600;
    color: #94a3b8;
    border-bottom: 1px solid #334155;
    white-space: nowrap;
}

td {
    padding: 0.75rem 1rem;
    color: #e2e8f0;
    border-bottom: 1px solid #1e293b;
}

tbody tr:hover {
    background-color: #1e293b;
}

/* Buttons */
.btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 0.5rem;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s ease;
    text-decoration: none;
}

.btn-primary {
    background-color: #4f46e5;
    color: white;
}

.btn-primary:hover {
    background-color: #4338ca;
}

.btn-secondary {
    background-color: #334155;
    color: #e2e8f0;
}

.btn-secondary:hover {
    background-color: #475569;
}

.btn-danger {
    background-color: #dc2626;
    color: white;
}

.btn-danger:hover {
    background-color: #b91c1c;
}

.btn-sm {
    padding: 0.25rem 0.75rem;
    font-size: 0.8125rem;
}

/* Forms */
.form-group {
    margin-bottom: 1rem;
}

.form-label {
    display: block;
    margin-bottom: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
    color: #94a3b8;
}

.form-input {
    width: 100%;
    padding: 0.5rem 0.75rem;
    background-color: #0f172a;
    border: 1px solid #334155;
    border-radius: 0.375rem;
    color: #e2e8f0;
    font-size: 0.875rem;
    transition: border-color 0.15s ease;
}

.form-input:focus {
    outline: none;
    border-color: #818cf8;
    box-shadow: 0 0 0 3px rgba(129, 140, 248, 0.1);
}

.form-input::placeholder {
    color: #475569;
}

.form-textarea {
    min-height: 6rem;
    resize: vertical;
}

.form-checkbox {
    width: 1rem;
    height: 1rem;
    accent-color: #4f46e5;
}

.form-error {
    margin-top: 0.25rem;
    font-size: 0.8125rem;
    color: #f87171;
}

/* Badges */
.badge {
    display: inline-flex;
    align-items: center;
    padding: 0.125rem 0.5rem;
    border-radius: 9999px;
    font-size: 0.75rem;
    font-weight: 500;
}

.badge-info { background-color: #1e3a5f; color: #60a5fa; }
.badge-success { background-color: #14532d; color: #4ade80; }
.badge-warning { background-color: #422006; color: #fbbf24; }
.badge-danger { background-color: #450a0a; color: #f87171; }

/* Pagination */
.pagination {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 0;
    font-size: 0.875rem;
    color: #94a3b8;
}

.pagination-buttons {
    display: flex;
    gap: 0.25rem;
}

/* Loading */
.loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 3rem;
    color: #64748b;
}

.spinner {
    width: 2rem;
    height: 2rem;
    border: 3px solid #334155;
    border-top-color: #818cf8;
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Alerts */
.alert {
    padding: 0.75rem 1rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    font-size: 0.875rem;
}

.alert-error {
    background-color: #450a0a;
    border: 1px solid #7f1d1d;
    color: #fca5a5;
}

.alert-success {
    background-color: #052e16;
    border: 1px solid #14532d;
    color: #86efac;
}

.alert-info {
    background-color: #0c1929;
    border: 1px solid #1e3a5f;
    color: #93c5fd;
}

/* Empty state */
.empty-state {
    text-align: center;
    padding: 3rem;
    color: #64748b;
}

.empty-state-icon {
    font-size: 3rem;
    margin-bottom: 1rem;
}

.empty-state-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: #94a3b8;
    margin-bottom: 0.5rem;
}

.empty-state-text {
    margin-bottom: 1.5rem;
}

/* Modal / Dialog */
.modal-backdrop {
    position: fixed;
    inset: 0;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 50;
}

.modal {
    background-color: #1e293b;
    border: 1px solid #334155;
    border-radius: 0.75rem;
    padding: 1.5rem;
    max-width: 32rem;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
}

.modal-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: #f1f5f9;
    margin-bottom: 1rem;
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
    margin-top: 1.5rem;
}

/* Utility classes */
.text-center { text-align: center; }
.text-right { text-align: right; }
.text-muted { color: #64748b; }
.text-sm { font-size: 0.875rem; }
.text-xs { font-size: 0.75rem; }
.font-mono { font-family: 'SF Mono', 'Fira Code', monospace; }
.mt-1 { margin-top: 0.25rem; }
.mt-2 { margin-top: 0.5rem; }
.mt-4 { margin-top: 1rem; }
.mb-2 { margin-bottom: 0.5rem; }
.mb-4 { margin-bottom: 1rem; }
.flex { display: flex; }
.items-center { align-items: center; }
.justify-between { justify-content: space-between; }
.gap-2 { gap: 0.5rem; }
.gap-4 { gap: 1rem; }
.grid-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; }
.truncate { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
"#;

    GeneratedFile::new(
        "frontend/assets/tailwind.css",
        content.to_string(),
        FileType::Other,
    )
}

// ============================================================================
// Frontend main.rs
// ============================================================================

fn generate_frontend_main(ctx: &GenerationContext) -> GeneratedFile {
    let content = format!(
        r#"{header}use dioxus::prelude::*;

mod app;
mod api;
mod components;
mod pages;
mod router;

fn main() {{
    tracing::info!("Starting {pkg} frontend");
    dioxus::launch(app::App);
}}
"#,
        header = file_header(&format!("{} — frontend entry point.", ctx.package_name())),
        pkg = ctx.package_name(),
    );

    GeneratedFile::new("frontend/src/main.rs", content, FileType::Rust)
}

// ============================================================================
// Frontend app.rs — root component
// ============================================================================

fn generate_frontend_app(ctx: &GenerationContext) -> GeneratedFile {
    let pkg = ctx.package_name();

    let content = format!(
        r#"{header}use dioxus::prelude::*;

use crate::components::navbar::Navbar;
use crate::components::sidebar::Sidebar;
use crate::router::Route;

/// Root application component.
///
/// Renders the main layout with a sidebar, navbar, and routed content area.
#[component]
pub fn App() -> Element {{
    rsx! {{
        div {{
            class: "app-container",

            // Sidebar navigation
            Sidebar {{}}

            // Main content area
            div {{
                class: "main-content",

                // Top navbar
                Navbar {{
                    title: "{pkg}".to_string(),
                }}

                // Routed content
                div {{
                    class: "content",
                    Router::<Route> {{}}
                }}
            }}
        }}
    }}
}}
"#,
        header = file_header("Root application component with layout."),
    );

    GeneratedFile::new("frontend/src/app.rs", content, FileType::Rust)
}

// ============================================================================
// Frontend router.rs — Dioxus router
// ============================================================================

fn generate_frontend_router(ctx: &GenerationContext) -> GeneratedFile {
    let mut content = String::with_capacity(2048);

    content.push_str(&file_header("Client-side router configuration."));

    content.push_str("use dioxus::prelude::*;\n\n");

    // Import page components
    content.push_str("use crate::pages::home::HomePage;\n");

    for entity in ctx.entities() {
        let info = EntityInfo::new(entity, ctx);
        if info.endpoint().is_some() {
            let snake = info.snake_name();
            let pascal = info.pascal_name();
            content.push_str(&format!(
                "use crate::pages::{snake}_list::{pascal}ListPage;\n"
            ));
            content.push_str(&format!(
                "use crate::pages::{snake}_form::{pascal}FormPage;\n"
            ));
        }
    }

    content.push('\n');

    // Route enum
    content.push_str(
        "/// Application routes.\n\
         ///\n\
         /// Each variant maps to a page component. The `#[route(\"…\")]` attribute\n\
         /// defines the URL pattern.\n",
    );
    content.push_str("#[derive(Clone, Routable, Debug, PartialEq)]\n");
    content.push_str("pub enum Route {\n");

    // Home route
    content.push_str("    /// Home / dashboard page.\n");
    content.push_str("    #[route(\"/\")]\n");
    content.push_str("    Home {},\n\n");

    // Per-entity routes
    for entity in ctx.entities() {
        let info = EntityInfo::new(entity, ctx);
        if info.endpoint().is_none() {
            continue;
        }

        let pascal = info.pascal_name();
        let plural = info.plural_name();

        // List page
        content.push_str(&format!("    /// {pascal} list page.\n"));
        content.push_str(&format!("    #[route(\"/{}\")] \n", plural));
        content.push_str(&format!("    {pascal}List {{}},\n\n"));

        // Create page
        content.push_str(&format!("    /// Create new {pascal} form.\n"));
        content.push_str(&format!("    #[route(\"/{}/new\")]\n", plural));
        content.push_str(&format!("    {pascal}New {{}},\n\n"));

        // Edit page
        content.push_str(&format!("    /// Edit {pascal} form.\n"));
        content.push_str(&format!("    #[route(\"/{}/{{id}}/edit\")]\n", plural));
        content.push_str(&format!("    {pascal}Edit {{ id: String }},\n\n"));
    }

    // 404 fallback
    content.push_str("    /// 404 Not Found page.\n");
    content.push_str("    #[route(\"/:..route\")]\n");
    content.push_str("    NotFound { route: Vec<String> },\n");

    content.push_str("}\n\n");

    // Render implementations — map enum variants to page components
    content.push_str(
        "// Note: Dioxus Routable derive macro handles rendering automatically.\n\
         // Each variant's component is resolved by naming convention:\n\
         //   Route::Home {} → fn Home() → crate::pages::home::HomePage\n\
         //\n\
         // If you need custom rendering, implement the `fn render()` method\n\
         // or use `#[layout(...)]` and `#[nest(...)]` attributes.\n",
    );

    GeneratedFile::new("frontend/src/router.rs", content, FileType::Rust)
}

// ============================================================================
// Helpers
// ============================================================================

/// Map a `DataType` to a Rust type string for use in the shared crate.
/// This uses standard library types without SeaORM-specific wrappers.
fn shared_rust_type(dt: &imortal_core::DataType, required: bool) -> String {
    use imortal_core::DataType;

    let base = match dt {
        DataType::String | DataType::Text => "String".to_string(),
        DataType::Int32 => "i32".to_string(),
        DataType::Int64 => "i64".to_string(),
        DataType::Float32 => "f32".to_string(),
        DataType::Float64 => "f64".to_string(),
        DataType::Bool => "bool".to_string(),
        DataType::Uuid => "uuid::Uuid".to_string(),
        DataType::DateTime => "chrono::DateTime<chrono::Utc>".to_string(),
        DataType::Date => "chrono::NaiveDate".to_string(),
        DataType::Time => "chrono::NaiveTime".to_string(),
        DataType::Bytes => "Vec<u8>".to_string(),
        DataType::Json => "serde_json::Value".to_string(),
        DataType::Optional(inner) => {
            return format!("Option<{}>", shared_rust_type(inner, true));
        }
        DataType::Array(inner) => {
            return format!("Vec<{}>", shared_rust_type(inner, true));
        }
        DataType::Reference { .. } => "uuid::Uuid".to_string(),
        DataType::Enum { name, .. } => name.clone(),
    };

    if !required {
        format!("Option<{}>", base)
    } else {
        base
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use imortal_core::DataType;
    use imortal_ir::{AuthConfig, EndpointGroup, Entity, Field, ProjectGraph, ProjectType};

    /// Helper: create a fullstack project with a User entity.
    fn fullstack_project() -> ProjectGraph {
        let mut project = ProjectGraph::new("my_app");
        project.config.project_type = ProjectType::Fullstack;
        project.config.package_name = "my_app".to_string();

        let mut user = Entity::new("User");
        user.config.timestamps = true;
        let user_id = user.id;

        let mut email = Field::new("email", DataType::String);
        email.required = true;
        email.unique = true;
        user.fields.push(email);

        let mut name = Field::new("name", DataType::String);
        name.required = true;
        user.fields.push(name);

        let mut pw = Field::new("password_hash", DataType::String);
        pw.required = true;
        pw.secret = true;
        user.fields.push(pw);

        project.add_entity(user);
        project.add_endpoint(EndpointGroup::new(user_id, "User"));

        project
    }

    /// Helper: REST-only project (should produce no frontend files).
    fn rest_only_project() -> ProjectGraph {
        let mut project = fullstack_project();
        project.config.project_type = ProjectType::RestApi;
        project
    }

    #[test]
    fn test_generate_frontend_returns_empty_for_rest_api() {
        let project = rest_only_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_frontend(&ctx);
        assert!(
            files.is_empty(),
            "REST-only project should not produce frontend files"
        );
    }

    #[test]
    fn test_generate_frontend_produces_files_for_fullstack() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_frontend(&ctx);

        assert!(
            !files.is_empty(),
            "Fullstack project should produce frontend files"
        );

        let paths: Vec<String> = files
            .iter()
            .map(|f| f.path.to_string_lossy().to_string())
            .collect();

        // Key files should exist
        assert!(
            paths.iter().any(|p| p == "Cargo.toml"),
            "Missing workspace Cargo.toml"
        );
        assert!(
            paths.iter().any(|p| p == "shared/Cargo.toml"),
            "Missing shared/Cargo.toml"
        );
        assert!(
            paths.iter().any(|p| p == "shared/src/lib.rs"),
            "Missing shared/src/lib.rs"
        );
        assert!(
            paths.iter().any(|p| p == "frontend/Cargo.toml"),
            "Missing frontend/Cargo.toml"
        );
        assert!(
            paths.iter().any(|p| p == "frontend/Dioxus.toml"),
            "Missing frontend/Dioxus.toml"
        );
        assert!(
            paths.iter().any(|p| p == "frontend/assets/tailwind.css"),
            "Missing tailwind.css"
        );
        assert!(
            paths.iter().any(|p| p == "frontend/src/main.rs"),
            "Missing frontend/src/main.rs"
        );
        assert!(
            paths.iter().any(|p| p == "frontend/src/app.rs"),
            "Missing frontend/src/app.rs"
        );
        assert!(
            paths.iter().any(|p| p == "frontend/src/router.rs"),
            "Missing frontend/src/router.rs"
        );
    }

    #[test]
    fn test_workspace_cargo_toml() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_workspace_cargo_toml(&ctx);
        let content = &file.content;

        assert!(content.contains("[workspace]"));
        assert!(content.contains("\"backend\""));
        assert!(content.contains("\"frontend\""));
        assert!(content.contains("\"shared\""));
        assert!(content.contains("[workspace.dependencies]"));
        assert!(content.contains("serde"));
        assert!(content.contains("uuid"));
    }

    #[test]
    fn test_shared_crate_cargo_toml() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let cargo = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("Cargo.toml"))
            .unwrap();
        let content = &cargo.content;

        assert!(content.contains("name = \"shared\""));
        assert!(content.contains("serde"));
        assert!(content.contains("uuid"));
        assert!(content.contains("chrono"));
    }

    #[test]
    fn test_shared_crate_lib_has_dtos() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();
        let content = &lib.content;

        assert!(content.contains("CreateUserDto"), "Missing CreateUserDto");
        assert!(content.contains("UpdateUserDto"), "Missing UpdateUserDto");
        assert!(content.contains("UserResponse"), "Missing UserResponse");
        assert!(
            content.contains("PaginatedResponse"),
            "Missing PaginatedResponse"
        );
        assert!(
            content.contains("PaginationParams"),
            "Missing PaginationParams"
        );
        assert!(content.contains("ApiError"), "Missing ApiError");
    }

    #[test]
    fn test_shared_crate_lib_excludes_secrets() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();
        let content = &lib.content;

        // UserResponse should NOT contain password_hash
        let response_section = content
            .split("pub struct UserResponse")
            .nth(1)
            .unwrap_or("");
        assert!(
            !response_section
                .split('}')
                .next()
                .unwrap_or("")
                .contains("password_hash"),
            "UserResponse should not expose password_hash"
        );
    }

    #[test]
    fn test_shared_crate_lib_has_timestamps() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();
        let content = &lib.content;

        assert!(content.contains("created_at"));
        assert!(content.contains("updated_at"));
        assert!(content.contains("DateTime<Utc>"));
    }

    #[test]
    fn test_frontend_cargo_toml() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_frontend_cargo_toml(&ctx);
        let content = &file.content;

        assert!(content.contains("name = \"my_app-frontend\""));
        assert!(content.contains("dioxus"));
        assert!(content.contains("reqwest"));
        assert!(content.contains("shared"));
        assert!(content.contains("serde"));
    }

    #[test]
    fn test_dioxus_toml() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_dioxus_toml(&ctx);
        let content = &file.content;

        assert!(content.contains("[application]"));
        assert!(content.contains("default_platform = \"web\""));
        assert!(content.contains("tailwind.css"));
        assert!(content.contains("my_app"));
    }

    #[test]
    fn test_tailwind_css_generated() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_tailwind_css(&ctx);
        let content = &file.content;

        assert!(content.contains(".sidebar"));
        assert!(content.contains(".navbar"));
        assert!(content.contains(".btn"));
        assert!(content.contains(".btn-primary"));
        assert!(content.contains(".form-input"));
        assert!(content.contains(".table-container"));
        assert!(content.contains(".card"));
        assert!(content.contains(".modal"));
        assert!(content.contains(".loading"));
        assert!(content.contains(".spinner"));
        assert!(content.contains(".alert"));
        assert!(content.contains(".pagination"));
        assert!(content.contains(".badge"));
        assert!(content.contains(".empty-state"));
    }

    #[test]
    fn test_frontend_main_rs() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_frontend_main(&ctx);
        let content = &file.content;

        assert!(content.contains("mod app;"));
        assert!(content.contains("mod api;"));
        assert!(content.contains("mod components;"));
        assert!(content.contains("mod pages;"));
        assert!(content.contains("mod router;"));
        assert!(content.contains("dioxus::launch(app::App)"));
    }

    #[test]
    fn test_frontend_app_rs() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_frontend_app(&ctx);
        let content = &file.content;

        assert!(content.contains("pub fn App()"));
        assert!(content.contains("Sidebar"));
        assert!(content.contains("Navbar"));
        assert!(content.contains("Router::<Route>"));
        assert!(content.contains("app-container"));
        assert!(content.contains("main-content"));
    }

    #[test]
    fn test_frontend_router() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_frontend_router(&ctx);
        let content = &file.content;

        assert!(content.contains("#[derive(Clone, Routable, Debug, PartialEq)]"));
        assert!(content.contains("pub enum Route"));
        assert!(content.contains("Home {}"));
        assert!(content.contains("UserList {}"));
        assert!(content.contains("UserNew {}"));
        assert!(content.contains("UserEdit { id: String }"));
        assert!(content.contains("NotFound"));
        assert!(content.contains("#[route(\"/\")]"));
        assert!(content.contains("#[route(\"/users\")]"));
        assert!(content.contains("#[route(\"/users/new\")]"));
    }

    #[test]
    fn test_frontend_router_multiple_entities() {
        let mut project = fullstack_project();

        let mut post = Entity::new("Post");
        post.config.timestamps = true;
        let post_id = post.id;
        let mut title = Field::new("title", DataType::String);
        title.required = true;
        post.fields.push(title);
        project.add_entity(post);
        project.add_endpoint(EndpointGroup::new(post_id, "Post"));

        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_frontend_router(&ctx);
        let content = &file.content;

        assert!(content.contains("UserList {}"));
        assert!(content.contains("PostList {}"));
        assert!(content.contains("/users"));
        assert!(content.contains("/posts"));
    }

    #[test]
    fn test_frontend_router_no_routes_for_entity_without_endpoint() {
        let mut project = fullstack_project();

        // Add entity WITHOUT endpoint
        let mut cat = Entity::new("Category");
        cat.config.timestamps = false;
        let mut name = Field::new("name", DataType::String);
        name.required = true;
        cat.fields.push(name);
        project.add_entity(cat);
        // No endpoint added for Category

        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_frontend_router(&ctx);
        let content = &file.content;

        assert!(content.contains("UserList"));
        assert!(
            !content.contains("CategoryList"),
            "Entity without endpoint should not have routes"
        );
    }

    #[test]
    fn test_shared_rust_type_mapping() {
        use imortal_core::DataType;

        assert_eq!(shared_rust_type(&DataType::String, true), "String");
        assert_eq!(shared_rust_type(&DataType::Int32, true), "i32");
        assert_eq!(shared_rust_type(&DataType::Int64, true), "i64");
        assert_eq!(shared_rust_type(&DataType::Float64, true), "f64");
        assert_eq!(shared_rust_type(&DataType::Bool, true), "bool");
        assert_eq!(shared_rust_type(&DataType::Uuid, true), "uuid::Uuid");
        assert_eq!(
            shared_rust_type(&DataType::DateTime, true),
            "chrono::DateTime<chrono::Utc>"
        );
        assert_eq!(shared_rust_type(&DataType::Json, true), "serde_json::Value");
        assert_eq!(shared_rust_type(&DataType::Bytes, true), "Vec<u8>");

        // Optional field
        assert_eq!(shared_rust_type(&DataType::String, false), "Option<String>");

        // Nested optional
        assert_eq!(
            shared_rust_type(&DataType::Optional(Box::new(DataType::String)), true),
            "Option<String>"
        );

        // Array
        assert_eq!(
            shared_rust_type(&DataType::Array(Box::new(DataType::Int32)), true),
            "Vec<i32>"
        );

        // Reference
        assert_eq!(
            shared_rust_type(
                &DataType::Reference {
                    entity_name: "User".into(),
                    field_name: "id".into()
                },
                true
            ),
            "uuid::Uuid"
        );
    }

    #[test]
    fn test_shared_update_dto_uses_option() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();
        let content = &lib.content;

        // Find the UpdateUserDto section
        let update_section = content
            .split("pub struct UpdateUserDto")
            .nth(1)
            .unwrap_or("");
        let update_body = update_section.split('}').next().unwrap_or("");

        // All fields in UpdateDto should be Option<T>
        for line in update_body.lines() {
            if line.trim().starts_with("pub ") && line.contains(':') {
                assert!(
                    line.contains("Option<"),
                    "Update DTO field should be Option<T>: {}",
                    line.trim()
                );
            }
        }
    }

    #[test]
    fn test_shared_create_dto_required_fields() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();
        let content = &lib.content;

        // CreateUserDto should have email and name as required String fields
        assert!(content.contains("pub email: String"));
        assert!(content.contains("pub name: String"));
    }

    #[test]
    fn test_generate_frontend_file_count() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_frontend(&ctx);

        // Workspace Cargo.toml + shared (2) + frontend scaffold (6) +
        // components (5) + pages (3+) + api (2) = 19+
        assert!(
            files.len() >= 15,
            "Expected at least 15 frontend files, got {}. Files: {:?}",
            files.len(),
            files
                .iter()
                .map(|f| f.path.to_string_lossy().to_string())
                .collect::<Vec<_>>()
        );
    }

    #[test]
    fn test_workspace_cargo_uses_project_edition() {
        let mut project = fullstack_project();
        project.config.rust_edition = "2021".to_string();

        let ctx = GenerationContext::from_project_default(&project);
        let file = generate_workspace_cargo_toml(&ctx);

        assert!(file.content.contains("edition = \"2021\""));
    }

    #[test]
    fn test_shared_crate_with_no_entities() {
        let mut project = ProjectGraph::new("empty_app");
        project.config.project_type = ProjectType::Fullstack;

        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        // Should still produce Cargo.toml and lib.rs
        assert_eq!(files.len(), 2);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();
        // Should still have pagination types even with no entities
        assert!(lib.content.contains("PaginatedResponse"));
        assert!(lib.content.contains("ApiError"));
    }

    #[test]
    fn test_shared_crate_pagination_response_is_generic() {
        let project = fullstack_project();
        let ctx = GenerationContext::from_project_default(&project);
        let files = generate_shared_crate(&ctx);

        let lib = files
            .iter()
            .find(|f| f.path.to_string_lossy().contains("lib.rs"))
            .unwrap();

        assert!(lib.content.contains("PaginatedResponse<T>"));
        assert!(lib.content.contains("pub items: Vec<T>"));
        assert!(lib.content.contains("pub total: u64"));
        assert!(lib.content.contains("pub page: u64"));
        assert!(lib.content.contains("pub per_page: u64"));
        assert!(lib.content.contains("pub total_pages: u64"));
    }
}
